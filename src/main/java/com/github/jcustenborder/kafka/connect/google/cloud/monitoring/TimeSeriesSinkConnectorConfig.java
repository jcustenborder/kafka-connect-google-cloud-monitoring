/**
 * Copyright Â© 2019 Jeremy Custenborder (jcustenborder@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.jcustenborder.kafka.connect.google.cloud.monitoring;

import com.github.jcustenborder.kafka.connect.google.cloud.GoogleCloudProjectConnectorConfig;
import com.github.jcustenborder.kafka.connect.utils.config.ConfigKeyBuilder;
import com.github.jcustenborder.kafka.connect.utils.config.ConfigUtils;
import com.github.jcustenborder.kafka.connect.utils.config.Description;
import com.github.jcustenborder.kafka.connect.utils.config.recommenders.Recommenders;
import com.github.jcustenborder.kafka.connect.utils.config.validators.Validators;
import com.google.common.base.Strings;
import org.apache.kafka.common.config.ConfigDef;
import org.apache.kafka.common.config.ConfigException;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

class TimeSeriesSinkConnectorConfig extends GoogleCloudProjectConnectorConfig {
  public static final String METRIC_NAME_PREFIX_CONF = "metric.name.prefix";
  static final String METRIC_NAME_PREFIX_DOC = "The prefix for the individual metrics.";

  public static final String METRIC_NAME_TYPE_CONF = "metric.name.type";
  static final String METRIC_NAME_TYPE_DOC = "metric.name.type" + ConfigUtils.enumDescription(MetricNameType.class);

  public static final String METRIC_NAME_FIELD_CONF = "metric.name.field";
  static final String METRIC_NAME_FIELD_DOC = "metric.name.type" + ConfigUtils.enumDescription(MetricNameType.class);
  public static final String METRIC_VALUE_FIELD_CONF = "metric.value.field";
  static final String METRIC_VALUE_FIELD_DOC = "metric.name.type" + ConfigUtils.enumDescription(MetricNameType.class);

  public static final String METRIC_FIELDS_CONF = "metric.fields";
  static final String METRIC_FIELDS_DOC = "The fields that contain the values to be written to asdf. The field name" +
      " will be prefixed with the value specified in `" + METRIC_NAME_PREFIX_CONF + "`. For example if `"
      + METRIC_NAME_PREFIX_CONF + "=example.com/sensors` and the value for this setting is `temperature,humidity` then " +
      "two metrics example.com/sensors/temperature and example.com/sensors/humidity will be created with the values " +
      "for those two fields.";

  public static final String METRIC_TIMESTAMP_FIELD_CONF = "metric.timestamp.field";
  public static final String METRIC_TIMESTAMP_FIELD_DOC = "To source the timestamp from the metric instead of Kafka," +
      " set this parameter to the name of the field containing the timestamp.";

  public static final String RESOURCE_TYPE_CONF = "resource.type";
  static final String RESOURCE_TYPE_DOC = "";
  public static final String RESOURCE_LABEL_FIELDS_CONF = "resource.label.fields";
  public static final String RESOURCE_LABEL_FIELDS_DOC = "Input fields containing the labels.";
  public static final String RESOURCE_LABEL_INPUTS_CONF = "resource.label.inputs";
  public static final String RESOURCE_LABEL_INPUTS_DOC = "Names of the labels in the input.";
  public static final String RESOURCE_LABEL_OUTPUTS_CONF = "resource.label.outputs";
  public static final String RESOURCE_LABEL_OUTPUTS_DOC = "Map from input labels to these output labels.";

  public enum MetricNameType {
    @Description("The name of the metric will be generated by adding the prefix in `" + METRIC_NAME_PREFIX_CONF + "`" +
        " and the name of the fields containing the value. For example if `" + METRIC_NAME_PREFIX_CONF + "` is configured to" +
        " `example.com/mysql` and a field name specified in `" + METRIC_FIELDS_CONF + "` is `bytes_received` then the " +
        " metric value sent to Google would be `example.com/mysql/bytes_received`")
    MetricFields,
    @Description("The field to retrieve the metric name from.")
    NameField
  }

  public final MetricNameType metricNameType;
  public final String metricNameField;
  public final String metricValueField;
  public final String metricTypePrefix;
  public final Set<String> metricFields;
  public final String metricTimestampPrefix;
  public final Set<String> resourceLabelFields;
  public final String resourceType;
  public final Map<String, String> resourceLabelMap = new LinkedHashMap<>();

  public TimeSeriesSinkConnectorConfig(Map<?, ?> originals) {
    super(config(), originals);
    this.metricTypePrefix = this.getString(METRIC_NAME_PREFIX_CONF);
    this.metricFields = ConfigUtils.getSet(this, METRIC_FIELDS_CONF);
    this.metricNameField = getString(METRIC_NAME_FIELD_CONF);
    this.metricValueField = getString(METRIC_VALUE_FIELD_CONF);
    this.metricNameType = ConfigUtils.getEnum(MetricNameType.class, this, METRIC_NAME_TYPE_CONF);
    this.metricTimestampPrefix = getString(METRIC_TIMESTAMP_FIELD_CONF);
    this.resourceLabelFields = ConfigUtils.getSet(this, RESOURCE_LABEL_FIELDS_CONF);
    this.resourceType = getString(RESOURCE_TYPE_CONF);

    List<String> resourceLabelInputs = this.getList(RESOURCE_LABEL_INPUTS_CONF);
    List<String> resourceLabelOutputs = this.getList(RESOURCE_LABEL_OUTPUTS_CONF);
    Iterator<String> inputs = resourceLabelInputs.iterator();
    Iterator<String> outputs = resourceLabelOutputs.iterator();

    while (inputs.hasNext() && outputs.hasNext()) {
      resourceLabelMap.put(inputs.next(), outputs.next());
    }
    if (inputs.hasNext() || outputs.hasNext()) {
      throw new ConfigException(
          RESOURCE_LABEL_INPUTS_CONF,
          resourceLabelInputs,
          String.format(
              "%s needs to be the same length as %s",
              RESOURCE_LABEL_INPUTS_CONF,
              RESOURCE_LABEL_OUTPUTS_CONF
          )
      );
    }

    switch (this.metricNameType) {
      case MetricFields:
        if (this.metricFields.isEmpty()) {
          throw new ConfigException(
              METRIC_FIELDS_CONF,
              this.metricFields,
              String.format(
                  "When %s == %s field(s) must be specified.",
                  METRIC_NAME_TYPE_CONF,
                  MetricNameType.MetricFields
              )
          );
        }
        break;
      case NameField:
        if (Strings.isNullOrEmpty(this.metricNameField)) {
          throw new ConfigException(
              METRIC_NAME_FIELD_CONF,
              this.metricNameField,
              String.format(
                  "When %s == %s field must be specified.",
                  METRIC_NAME_TYPE_CONF,
                  MetricNameType.NameField
              )
          );
        }
        if (Strings.isNullOrEmpty(this.metricValueField)) {
          throw new ConfigException(
              METRIC_VALUE_FIELD_CONF,
              this.metricValueField,
              String.format(
                  "When %s == %s field must be specified.",
                  METRIC_NAME_TYPE_CONF,
                  MetricNameType.NameField
              )
          );
        }
        break;
    }
  }

  public static ConfigDef config() {
    return GoogleCloudProjectConnectorConfig.config()
        .define(
            ConfigKeyBuilder.of(METRIC_NAME_TYPE_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_NAME_TYPE_DOC)
                .validator(Validators.validEnum(MetricNameType.class))
                .build()
        )
        .define(
            ConfigKeyBuilder.of(METRIC_NAME_FIELD_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_NAME_FIELD_DOC)
                .defaultValue("")
                .recommender(Recommenders.visibleIf(METRIC_NAME_TYPE_CONF, MetricNameType.NameField.toString()))
                .build()
        )
        .define(
            ConfigKeyBuilder.of(METRIC_VALUE_FIELD_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_VALUE_FIELD_DOC)
                .defaultValue("")
                .recommender(Recommenders.visibleIf(METRIC_NAME_TYPE_CONF, MetricNameType.NameField.toString()))
                .build()
        )
        .define(
            ConfigKeyBuilder.of(METRIC_NAME_PREFIX_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_NAME_PREFIX_DOC)
                .build()
        ).define(
            ConfigKeyBuilder.of(METRIC_FIELDS_CONF, ConfigDef.Type.LIST)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_FIELDS_DOC)
                .defaultValue(Collections.EMPTY_LIST)
                .recommender(Recommenders.visibleIf(METRIC_NAME_TYPE_CONF, MetricNameType.MetricFields.toString()))
                .build()
        ).define(
            ConfigKeyBuilder.of(METRIC_TIMESTAMP_FIELD_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(METRIC_TIMESTAMP_FIELD_DOC)
                .defaultValue("")
                .build()
        ).define(
            ConfigKeyBuilder.of(RESOURCE_LABEL_FIELDS_CONF, ConfigDef.Type.LIST)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(RESOURCE_LABEL_FIELDS_DOC)
                .build()
        ).define(
            ConfigKeyBuilder.of(RESOURCE_LABEL_INPUTS_CONF, ConfigDef.Type.LIST)
                .importance(ConfigDef.Importance.HIGH)
                .defaultValue(Collections.EMPTY_LIST)
                .documentation(RESOURCE_LABEL_INPUTS_DOC)
                .build()
        ).define(
            ConfigKeyBuilder.of(RESOURCE_LABEL_OUTPUTS_CONF, ConfigDef.Type.LIST)
                .importance(ConfigDef.Importance.HIGH)
                .defaultValue(Collections.EMPTY_LIST)
                .documentation(RESOURCE_LABEL_OUTPUTS_DOC)
                .build()
        ).define(
            ConfigKeyBuilder.of(RESOURCE_TYPE_CONF, ConfigDef.Type.STRING)
                .importance(ConfigDef.Importance.HIGH)
                .documentation(RESOURCE_TYPE_DOC)
                .build()
        );
  }
}
